%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.0 (4/2/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} command for typesetting SI units
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
%\usepackage{lstcoq}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{graphicx} % Required for the inclusion of images

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\newcommand{\pyc}{\texttt{.pyc~}}

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Project 1 - Report} % Title

\author{Cibele \textsc{Freire} and Theodore \textsc{Sudol}} % Author name

\date{\today} % Date for the report
\newcommand{\link}[3]{%
    \underline{\texttt{\href{#1:#2}{#3}}}%
}

\begin{document}

%\lstset{language=Coq} probably should set this to typescript

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
%Date Performed: & January 1, 2012 \\ % Date the experiment was performed
%Partners: & James Smith \\ % Partner names
%& Mary Smith \\
Course: CPMSCI 630 - Systems \\
Instructor: Professor Emery Berger % Instructor/supervisor
\end{tabular}
\end{center}



% If you wish to include an abstract, uncomment the lines below
%\begin{abstract}
%This document is In this document we describe how the development of this system was conducted. The choices that were made 
%\end{abstract}


\section{Introduction}\label{intro}

\paragraph{}
The project consists of designing and implementing an interpreter for Python bytecode in TypeScript, a typed superset of JavaScript. The interpreter is designed to work in the browser, loading and executing programs from Python bytecode files, i.e. \pyc files. It can also be run with the Node.JS framework.

\paragraph{}
In Section~\ref{parser} we explain how we parsed the bytecode, what is the Marshal format and what data structures we used. In Section~\ref{interpreter} we explain the design of the interpreter and what we were able to implement.

\section{Parser}\label{parser}

\paragraph{}
The bytecode generated by a Python compiler is stored in marshal format. Each \pyc file is composed of:

\begin{itemize}
	\item Magic number: consist of the first 8 bytes of the \pyc file and it indicates from which Python version the bytecode was generated;
	\item Date: the next 8 bytes and it indicates the date of compilation;
	\item Code object: the remaining of the file. More details on Section~\ref{code object}
\end{itemize}

We define the class Unmarshaller to handle the parsing phase. The class has the attributes index, input, magicNumber, date, internedStrs, and output.

\begin{itemize}
	\item \texttt{index}: it keeps track of which byte of the file is being currently read 
	\item \texttt{input}: the path for the \pyc file that is going to be processed
	\item \texttt{magicNumber}: stores the magic number
	\item \texttt{date}: stores the date of compilation
	\item \texttt{internedStrs}:
	\item \texttt{output}: the code object generated after parsing the \pyc file
\end{itemize}

The following are the central methods implemented by this class.

\begin{itemize}
	\item \texttt{value()}:
	\item \texttt{unmarshallCodeString()}:
	\item \texttt{unmarshal()}:
\end{itemize}

\paragraph{}
The Unmarshaller, as we have named it, parses a \pyc file by recursing over the file and creating a code object. The Marshal format encodes data by using a single character for the object's type (`\texttt{i}' for 32-bit integers, `\texttt{s}' for strings, and so on) followed by some number of bytes. A long integer (Python's arbitrary precision integer type) consists of the letter `\texttt{l}', a 32-bit integer indicating the length of the number, and a corresponding sequence of base-15 digits. Data whose type are already known, such as the fields of code objects (discussed below), are stored as raw bytes.

\paragraph{}
The advantage of this design is being able to define the marshal format algebraically. A tuple, a common data structure in \pyc files, is stored the number of elements (a 32-bit integer) followed by the sequence of elements. The Unmarshaller decodes the tuples by reading the length, creating an empty array, unmarshalling each element in turn and pushing it into the array. Since we don't know anything about the contents of the tuple besides the number of elements, we can extract arbitrary objects with no problem.

\paragraph{}
Our Unmarshaller was inspired in part by Cody Brocious's work with \pyc files and his RMarshal gem\footnote{\url{https://github.com/daeken/RMarshal}}.

\subsection{Code objects}\label{code object}

\paragraph{}
A code object is a representation of a block of executable Python code. These can include functions, modules and classes. Of course, a block of code is more than just a sequence of opcodes. Each code object includes pieces of metadata, such as the name of the function and the number of arguments. There's also information that's useful for debugging, like the first line number of the code relative to the original source file. All of this data is included in the \pyc file. The Unmarshaller returns a code object when it has finished unmarshalling a file.

\paragraph{}
We designed our code object class (Py\_CodeObject) around the official Python documentation, with particular inspiration from the \texttt{inspect} library. Due the limitations of our interpreter, not all of the fields were needed. For example, the \texttt{co\_cellvars} field is used for closures, which we did not implement. However, we included these fields for the sake of completeness and compatibility with the Python design.

\paragraph{}
The following are the attributes of the Py\_CodeObject class:

\begin{itemize}
	\item \texttt{argcounts}: the number of arguments that the function/code requires
	\item \texttt{nlocals}: number of local variables
	\item \texttt{stacksize}: the depth of the stack that is going to be used by that code
	\item \texttt{code}: the code that will be executed. It consists of a sequence of bytecode instructions, each of which has an opcode associated to it. The list of instructions and their respective opcodes can be found in \texttt{Systems630-Project1/src/opcodes.ts} on the repository.
	\item \texttt{consts}: the constant objects. Those can ben numbers, strings, collections (such as lists, or dictionaries), and also code objects.  
	\item \texttt{names}: 
	\item \texttt{varnames}: the names of all the variables defined in the code object
	\item \texttt{filename}: the name of the file the originated the code object
	\item \texttt{name}: indicates if the code object refers to a function, and then it is the name of the function, or it will be \texttt{module}, indicating that it is the ``main'' code.
	\item \texttt{firstlineno}: the line number where this code object started on the \texttt{.py} that compiled into the \pyc file
	\item \texttt{flags}, \texttt{freevars}, \texttt{cellvars}, \texttt{lnotab}: among the fields we did not use
	\end{itemize}

\paragraph{}
Code objects are primary used in the interpreter as components of frame objects, which are discussed in section~\ref{py-frameobject}.

\section{Interpreter}\label{interpreter}

\paragraph{}
Our Python interpreter is based around a simple Fetch-Decode-Execute loop. In each cycle, the interpreter reads an opcode, finds the appropriate function, and executes that function. Python bytecode uses a stack-based design, but the interpreter does not maintain its own stack. Instead, frame objects are used to maintain interpreter state.

\subsection{Frame Objects}\label{py-frameobject}
\paragraph{}
In a typical execution model, each function call pushes a stack frame to a central stack, which contains the function's arguments and other information. In our Python interpreter, the situation is reversed: each frame has its own stack. Arguments to the function are contained in dictionaries on the stack. When a Python function is called, the interpreter creates a new stackframe with the variables in the current scope, a pointer to the previous stack frame, and the code to execute. The interpreter then starts executing this frame.

\paragraph{}
As with the code objects mentioned above, our implementation of frame objects was inspired by the official Python documentation. However, we originally used a single stack in the interpreter, since it was the simplest appraoch and the documentation did not mention the stack. We found that, while this implementation was simple, it made more complex code difficult. For example, the central stack design had no clear boundary between function calls, and a function would just leave its return value on the stack when it exited. Having a stack per frame gave the RETURN\_VALUE opcode significance and clearly marked where the interpreter should stop executing the current frame. It also made clean up easier, since the leftover data could be discarded.

\subsection{Additional Data Objects}

\paragraph{}
We used several other data objects in our interpreter. Two of these are simple constants: None, Python's Null type; and NotImplemented, an error message used heavily by numeric methods. NotImplemented is discussed further in section~\ref{numeric}.

\paragraph{}
The other type of data object is Function Objects. While code objects are the ``physical'' representation of code and frame objects are the ``execution'' representation, function objects are the data representation of functions. A function is marshalled as just another code object. The interpreter then loads this code object and the function's default arguments before using the MAKE\_FUNCTION bytecode to create a function object.

\paragraph{}
Function objects are primarily used to associate a function with its default arguments and the context (scope) of the program at the time of creation. The function object also wraps the original code object. The function object is stored for later use, namely when the CALL\_FUNCTION opcode is used. At this time, the function object is pushed to the stack with the arguments for this particular call. The opcode unwraps the code object, associates the arguments with their local variables, creates a new frame object, and tells the interpreter to execute this new frame.

\subsection{Numeric Types} \label{numeric}

\paragraph{}
Besides functions, another significant feature of our interpreter is the numeric methods. Python provides four basic numeric types: Integers (32- and 64-bit), Long Integers (arbitrary precision), Floating-point numbers (IEEE-754) and Complex numbers. However, programmers do not need to concern themselves with which number type they are using, as Python will invisibly transition between types as needed. This is a key feature of the language, and we felt it was important to make sure our numbers met this standard.

\paragraph{}
Our original implementation was straightforward: 32-bit integers and floating-point numbers were represented using normal JavaScript numbers, 64-bit integers were stored in gLong\footnote{A 64-bit integer library developed at Google, later adapted to TypeScript as part of the Doppion project. \url{https://github.com/plasma-umass/doppio/blob/master/src/gLong.ts}} objects, longs in Decimal\footnote{An arbitrary-precision library created by Michael Mclaughlin \url{https://github.com/MikeMcl/decimal.js/}} objects, and complex numbers as a simple class with two JavaScript number fields, representing the real and imaginary parts of the number. The limitations of this approach became clear very quickly. The key problem was widening; Python defines a hierarchy of numeric types, where integers are narrower than longs are narrower than floats are narrower than complex numbers. An operation between a narrow and wider number would cast the narrow number up to the wider type. This was impossible when 32-bit integers were both distinct from 64-bit integers (Python does not make this distinction) and indistinguishable from floating-point numbers. Additionally, these operations are defined by functions (e.g. addition has an \texttt{add} function) and reverse functions (e.g. \texttt{radd}). Reverse functions are used in widening. If \texttt{a + b => a.radd(b)} is undefined due to \texttt{b}'s type, \texttt{b.radd(a)} is called instead. These functions would have to be added to the class definitions, which was impossible for floats since they are primitive types.

\paragraph{}
We implemented one class for each type: Py\_Int, which combined 32- and 64-bit integers in one class with gLong objects as the backend; Py\_Long, which simply wrapped Decimal objects; Py\_Float, which used JavaScript number; and Py\_Complex, which used two Py\_Floats for its fields. In each class, we implemented the mathematical operations and their reversed counterparts. Since each operation needed to handle the widening operation, we defined a general ``mathOp'' function, which widens arguments or defers execution as needed. Each operation passes an anonymous function to this function. We used a similar approach to define the comparison operators, since they also widened arguments as needed. The \texttt{mathOp} function for the Py\_Float class looks as follows:

\begin{verbatim}
private mathOp(other: any, op: (a: Py_Float, b: Py_Float) => any): any {
    if (other.isInt)
        return op(this, Py_Float.fromPy_Int(other));
    else if (other.isLong)
        return op(this, Py_Float.fromPy_Long(other));
    else if (other.isFloat)
        return op(this, other);
    else
        return NotImplemented;
}
\end{verbatim}

``NotImplemented'' indicates that Py\_Float cannot handle this particular argument type, and \texttt{other.r<op>} should be used instead. The interpreter determines with operation to use and handles the cases of using the reversed operation. If both functions return NotImplemented, the interpreter throws an error indicating that the types are incompatible with the operation.

\paragraph{}
We encountered several other challenges while implementing the numeric types. For example, Python implements modulo in a somewhat unusual fashion. Modulo between two positive integers is straightforward, but things get unusual when floats, negative values and complex numbers are involved. Python has two rules for modulo: $(a \% b)$ will have the same sign as $b$, and $a =  \mathrm{floor}(a / b) * b + (a \% b)$. These rules must be held to for all modulo operations on any combination of types, and this invariant was very helpful for making our number implementation correct.

\section{Using the Interpreter}

\subsection{In the Browser}

\subsection{On the Command Line: Node.JS}

\subsection{Test Suite}

\subsection{Not implemented}

\paragraph{}
As mentioned in the \textsc{Readme},


%\bibliographystyle{unsrt}
%\bibliography{sample}

%----------------------------------------------------------------------------------------


\end{document}
