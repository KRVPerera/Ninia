%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.0 (4/2/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} command for typesetting SI units
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
%\usepackage{lstcoq}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{graphicx} % Required for the inclusion of images

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\newcommand{\pyc}{\texttt{.pyc~}}

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Project 1 - Report} % Title

\author{Cibele \textsc{Freire} and Theodore \textsc{Sudol}} % Author name

\date{\today} % Date for the report
\newcommand{\link}[3]{%
    \underline{\texttt{\href{#1:#2}{#3}}}%
}

\begin{document}

%\lstset{language=Coq} probably should set this to typescript

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
%Date Performed: & January 1, 2012 \\ % Date the experiment was performed
%Partners: & James Smith \\ % Partner names
%& Mary Smith \\
Instructor: & Professor Emery Berger % Instructor/supervisor
\end{tabular}
\end{center}



% If you wish to include an abstract, uncomment the lines below
%\begin{abstract}
%This document is In this document we describe how the development of this system was conducted. The choices that were made 
%\end{abstract}


\section{Introduction}\label{intro}

\paragraph{}
The project consists of designing and implementing an interpreter for Python bytecode in TypeScript, a typed superset of JavaScript. The interpreter is designed to work in the browser, loading and executing programs from Python bytecode files, i.e. \pyc files. It can also be run with the Node.JS framework.

\paragraph{}
In Section~\ref{parser} we explain how we parsed the bytecode, what is the Marshall format and what data structures we used. In Section~\ref{interpreter} we explain the design of the interpreter and what we were able to implement.

\section{Parser}\label{parser}

\paragraph{}
The bytecode generated by a Python compiler is stored in marshal format. Each \pyc file is composed of:

\begin{itemize}
	\item Magic number: consist of the first 8 bytes of the \pyc file and it indicates from which Python version the bytecode was generated;
	\item Date: the next 8 bytes and it indicates the date of compilation;
	\item Code object: the remaining of the file. More details on Section~\ref{code object}
\end{itemize}

We define the class Unmarshaller to handle the parsing phase. The class has the attributes index, input, magicNumber, date, internedStrs, and output.

\begin{itemize}
	\item \texttt{index}: it keeps track of which byte of the file is being currently read 
	\item \texttt{input}: the path for the \pyc file that is going to be processed
	\item \texttt{magicNumber}: stores the magic number
	\item \texttt{date}: stores the date of compilation
	\item \texttt{internedStrs}:
	\item \texttt{output}: the code object generated after parsing the \pyc file
\end{itemize}

The following are the central methods implemented by this class.

\begin{itemize}
	\item \texttt{value()}:
	\item \texttt{unmarshallCodeString()}:
	\item \texttt{unmarshal()}:
\end{itemize}

\paragraph{}
The Unmarshaller, as we have named it, parses a \pyc file by recursing over the file and creating a code object. The Marshal format encodes data by using a single character for the object's type (`\texttt{i}' for 32-bit integers, `\texttt{s}' for strings, and so on) followed by some number of bytes. A long integer (Python's arbitrary precision integer type) consists of the letter `\texttt{l}', a 32-bit integer indicating the length of the number, and a corresponding sequence of base-15 digits. Data whose type are already known, such as the fields of code objects (discussed below), are stored as raw bytes.

\paragraph{}
The advantage of this design is being able to define the marshal format algebraically. A tuple, a common data structure in \pyc files, is stored the number of elements (a 32-bit integer) followed by the sequence of elements. The Unmarshaller decodes the tuples by reading the length, creating an empty array, unmarshalling each element in turn and pushing it into the array. Since we don't know anything about the contents of the tuple besides the number of elements, we can extract arbitrary objects with no problem.

\paragraph{}
Our Unmarshaller was inspired in part by Cody Brocious's work with \pyc files and his RMarshal gem\footnote{\url{https://github.com/daeken/RMarshal}}.

\subsection{Code objects}\label{code object}

\paragraph{}
A code object is a representation of a block of executable Python code. These can include functions, modules and classes. Of course, a block of code is more than just a sequence of opcodes. Each code object includes pieces of metadata, such as the name of the function and the number of arguments. There's also information that's useful for debugging, like the first line number of the code relative to the original source file. All of this data is included in the \pyc file. The Unmarshaller returns a code object when it has finished unmarshalling a file.

\paragraph{}
We designed our code object class (Py\_CodeObject) around the official Python documentation, with particular inspiration from the \texttt{inspect} library. Due the limitations of our interpreter, not all of the fields were needed. For example, the \texttt{co\_cellvars} field is used for closures, which we did not implement. However, we included these fields for the sake of completeness and compatibility with the Python design.

\paragraph{}
Code objects are primary used in the interpreter as components of frame objects, which are discussed in section~\ref{py-frameobject}.

\section{Interpreter}\label{interpreter}

\paragraph{}
Our Python interpreter is based around a simple Fetch-Decode-Execute loop. In each cycle, the interpreter reads an opcode, finds the appropriate function, and executes that function. Python bytecode uses a stack-based design, but the interpreter does not maintain its own stack. Instead, frame objects are used to maintain interpreter state.

\subsection{Frame Objects}\label{py-frameobject}
\paragraph{}
In a typical execution model, each function call pushes a stack frame to a central stack, which contains the function's arguments and other information. In our Python interpreter, the situation is reversed: each frame has its own stack. Arguments to the function are contained in dictionaries on the stack. When a Python function is called, the interpreter creates a new stackframe with the variables in the current scope, a pointer to the previous stack frame, and the code to execute. The interpreter then starts executing this frame.

\paragraph{}
As with the code objects mentioned above, our implementation of frame objects was inspired by the official Python documentation. However, we originally used a single stack in the interpreter, since it was the simplest appraoch and the documentation did not mention the stack. We found that, while this implementation was simple, it made more complex code difficult. For example, the central stack design had no clear boundary between function calls, and a function would just leave its return value on the stack when it exited. Having a stack per frame gave the RETURN\_VALUE opcode significance and clearly marked where the interpreter should stop executing the current frame. It also made clean up easier, since the leftover data could be discarded.

\subsection{Additional Data Objects}

\paragraph{}
We used several other data objects in our interpreter. Two of these are simple constants: None, Python's Null type; and NotImplemented, an error message used heavily by numeric methods. NotImplemented is discussed further in section~\ref{numeric}.

\paragraph{}
The other type of data object is Function Objects. While code objects are the ``physical'' representation of code and frame objects are the ``execution'' representation, function objects are the data representation of functions. A function is marshalled as just another code object


\subsection{Numeric methods} \label{numeric}

Issues with numeric methods and how they were fixed.

\subsection{Not implemented}

\subsection{Using the browser}



%\bibliographystyle{unsrt}
%\bibliography{sample}

%----------------------------------------------------------------------------------------


\end{document}
